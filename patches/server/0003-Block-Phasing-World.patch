From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alexander=20S=C3=B6derberg?= <sauilitired@gmail.com>
Date: Wed, 4 Mar 2020 13:26:56 +0100
Subject: [PATCH] Block Phasing (World)


diff --git a/src/main/java/net/minecraft/server/BlockAccessAir.java b/src/main/java/net/minecraft/server/BlockAccessAir.java
index 30cbfc8eac20910aa55951e3dce63862f5a43c37..18e8d7182e4cf46d1e31abdeae33efca96bb7cb5 100644
--- a/src/main/java/net/minecraft/server/BlockAccessAir.java
+++ b/src/main/java/net/minecraft/server/BlockAccessAir.java
@@ -35,4 +35,11 @@ public enum BlockAccessAir implements IBlockAccess {
     public Fluid getFluid(BlockPosition blockposition) {
         return FluidTypes.EMPTY.h();
     }
+
+    // Servett Start
+    @Override public IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        return getType(position);
+    }
+    // Servett End
+
 }
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index 83c5c83292546d76e249b40d24f706c6323ddb3e..a295a8b4ffae7f419aa8148e5b1a642e80290017 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -4,6 +4,10 @@ import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.Dynamic;
 import com.mojang.datafixers.types.DynamicOps;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.annotation.concurrent.Immutable;
 import java.util.List;
 import java.util.Spliterator.OfInt;
 import java.util.Spliterators.AbstractSpliterator;
@@ -11,9 +15,6 @@ import java.util.function.Consumer;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-import javax.annotation.concurrent.Immutable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 @Immutable
 public class BlockPosition extends BaseBlockPosition implements MinecraftSerializable {
@@ -99,6 +100,13 @@ public class BlockPosition extends BaseBlockPosition implements MinecraftSeriali
         return new BlockPosition(b(i), c(i), d(i));
     }
 
+    // Servett Start
+    // Obfuscation Helper
+    public static long at(int x, int y, int z) {
+        return a(x, y, z);
+    }
+    // Servett End
+
     public static long a(int i, int j, int k) {
         long l = 0L;
 
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 50244d75e277541a5d60f176d031c02601435792..465b5e4c24d77fea0ccbafe4e13ba64622478764 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -7,30 +7,37 @@ import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.annotation.Nullable;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 public class Chunk implements IChunkAccess {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    public static final ChunkSection a = null; public static final ChunkSection EMPTY_CHUNK_SECTION = Chunk.a; // Paper - OBFHELPER
+    public static final ChunkSection a = null;
+    public static final ChunkSection EMPTY_CHUNK_SECTION = Chunk.a; // Paper - OBFHELPER
     private final ChunkSection[] sections;
     private BiomeStorage d;
     private final Map<BlockPosition, NBTTagCompound> e;
-    public boolean loaded; public boolean isLoaded() { return loaded; } // Paper - OBFHELPER
+    public boolean loaded;
+
+    public boolean isLoaded() {
+        return loaded;
+    } // Paper - OBFHELPER
+
     public final World world;
     public final Map<HeightMap.Type, HeightMap> heightMap;
     private final ChunkConverter i;
@@ -45,25 +52,27 @@ public class Chunk implements IChunkAccess {
     public long lastSaved; // Paper
     private volatile boolean s;
     private long inhabitedTime;
-    @Nullable
-    private Supplier<PlayerChunk.State> u;
-    @Nullable
-    private Consumer<Chunk> v;
-    private final ChunkCoordIntPair loc; public final long coordinateKey; // Paper - cache coordinate key
+    @Nullable private Supplier<PlayerChunk.State> u;
+    @Nullable private Consumer<Chunk> v;
+    private final ChunkCoordIntPair loc;
+    public final long coordinateKey; // Paper - cache coordinate key
     private volatile boolean x;
 
-    final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
+    final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList =
+        new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
     public Chunk(World world, ChunkCoordIntPair chunkcoordintpair, BiomeStorage biomestorage) {
-        this(world, chunkcoordintpair, biomestorage, ChunkConverter.a, TickListEmpty.b(), TickListEmpty.b(), 0L, (ChunkSection[]) null, (Consumer) null);
+        this(world, chunkcoordintpair, biomestorage, ChunkConverter.a, TickListEmpty.b(),
+            TickListEmpty.b(), 0L, (ChunkSection[]) null, (Consumer) null);
     }
 
     // Paper start
     public final co.aikar.util.Counter<String> entityCounts = new co.aikar.util.Counter<>();
     public final co.aikar.util.Counter<String> tileEntityCounts = new co.aikar.util.Counter<>();
+
+
     private class TileEntityHashMap extends java.util.HashMap<BlockPosition, TileEntity> {
-        @Override
-        public TileEntity put(BlockPosition key, TileEntity value) {
+        @Override public TileEntity put(BlockPosition key, TileEntity value) {
             TileEntity replaced = super.put(key, value);
             if (replaced != null) {
                 replaced.setCurrentChunk(null);
@@ -76,8 +85,7 @@ public class Chunk implements IChunkAccess {
             return replaced;
         }
 
-        @Override
-        public TileEntity remove(Object key) {
+        @Override public TileEntity remove(Object key) {
             TileEntity removed = super.remove(key);
             if (removed != null) {
                 removed.setCurrentChunk(null);
@@ -86,13 +94,17 @@ public class Chunk implements IChunkAccess {
             return removed;
         }
     }
+
+
     // Track the number of minecarts and items
     // Keep this synced with entitySlices.add() and entitySlices.remove()
     private final int[] itemCounts = new int[16];
     private final int[] inventoryEntityCounts = new int[16];
     // Paper end
 
-    public Chunk(World world, ChunkCoordIntPair chunkcoordintpair, BiomeStorage biomestorage, ChunkConverter chunkconverter, TickList<Block> ticklist, TickList<FluidType> ticklist1, long i, @Nullable ChunkSection[] achunksection, @Nullable Consumer<Chunk> consumer) {
+    public Chunk(World world, ChunkCoordIntPair chunkcoordintpair, BiomeStorage biomestorage,
+        ChunkConverter chunkconverter, TickList<Block> ticklist, TickList<FluidType> ticklist1,
+        long i, @Nullable ChunkSection[] achunksection, @Nullable Consumer<Chunk> consumer) {
         this.sections = new ChunkSection[16];
         this.e = Maps.newHashMap();
         this.heightMap = Maps.newEnumMap(HeightMap.Type.class);
@@ -102,7 +114,9 @@ public class Chunk implements IChunkAccess {
         this.n = new ShortList[16];
         this.entitySlices = (List[]) (new List[16]); // Spigot
         this.world = world;
-        this.loc = chunkcoordintpair; this.coordinateKey = MCUtil.getCoordinateKey(chunkcoordintpair); // Paper - cache coordinate key
+        this.loc = chunkcoordintpair;
+        this.coordinateKey =
+            MCUtil.getCoordinateKey(chunkcoordintpair); // Paper - cache coordinate key
         this.i = chunkconverter;
         HeightMap.Type[] aheightmap_type = HeightMap.Type.values();
         int j = aheightmap_type.length;
@@ -130,17 +144,24 @@ public class Chunk implements IChunkAccess {
                 for (ChunkSection section : achunksection) {
                     if (section != null) {
                         section.chunk = this;
-                        int offset = com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationKey(0, section.yPos, 0);
-                        for (it.unimi.dsi.fastutil.longs.LongIterator iterator = section.tickingList.getRawIterator(); iterator.hasNext();) {
+                        int offset = com.destroystokyo.paper.util.maplist.IBlockDataList
+                            .getLocationKey(0, section.yPos, 0);
+                        for (it.unimi.dsi.fastutil.longs.LongIterator iterator =
+                             section.tickingList.getRawIterator(); iterator.hasNext(); ) {
                             long raw = iterator.nextLong();
-                            this.tickingList.add(com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationFromRaw(raw) + offset, com.destroystokyo.paper.util.maplist.IBlockDataList.getBlockDataFromRaw(raw));
+                            this.tickingList.add(com.destroystokyo.paper.util.maplist.IBlockDataList
+                                    .getLocationFromRaw(raw) + offset,
+                                com.destroystokyo.paper.util.maplist.IBlockDataList
+                                    .getBlockDataFromRaw(raw));
                         }
                     }
                 }
                 // Paper end
                 System.arraycopy(achunksection, 0, this.sections, 0, this.sections.length);
             } else {
-                Chunk.LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", achunksection.length, this.sections.length);
+                Chunk.LOGGER
+                    .warn("Could not set level chunk sections, array length is {} instead of {}",
+                        achunksection.length, this.sections.length);
             }
         }
 
@@ -149,6 +170,7 @@ public class Chunk implements IChunkAccess {
     }
 
     public org.bukkit.Chunk bukkitChunk;
+
     public org.bukkit.Chunk getBukkitChunk() {
         return bukkitChunk;
     }
@@ -158,7 +180,8 @@ public class Chunk implements IChunkAccess {
     // CraftBukkit end
 
     // Paper start
-    public final com.destroystokyo.paper.util.maplist.EntityList entities = new com.destroystokyo.paper.util.maplist.EntityList();
+    public final com.destroystokyo.paper.util.maplist.EntityList entities =
+        new com.destroystokyo.paper.util.maplist.EntityList();
     public PlayerChunk playerChunk;
     // Paper end
 
@@ -175,12 +198,14 @@ public class Chunk implements IChunkAccess {
     boolean loadedTicketLevel;
 
     private long neighbourChunksLoadedBitset;
-    private final Chunk[] loadedNeighbourChunks = new Chunk[(NEIGHBOUR_CACHE_RADIUS * 2 + 1) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)];
+    private final Chunk[] loadedNeighbourChunks =
+        new Chunk[(NEIGHBOUR_CACHE_RADIUS * 2 + 1) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)];
 
     private static int getNeighbourIndex(final int relativeX, final int relativeZ) {
         // index = (relativeX + NEIGHBOUR_CACHE_RADIUS) + (relativeZ + NEIGHBOUR_CACHE_RADIUS) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)
         // optimised variant of the above by moving some of the ops to compile time
-        return relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)));
+        return relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS
+            + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)));
     }
 
     public final Chunk getRelativeNeighbourIfLoaded(final int relativeX, final int relativeZ) {
@@ -188,12 +213,16 @@ public class Chunk implements IChunkAccess {
     }
 
     public final boolean isNeighbourLoaded(final int relativeX, final int relativeZ) {
-        return (this.neighbourChunksLoadedBitset & (1L << getNeighbourIndex(relativeX, relativeZ))) != 0;
+        return (this.neighbourChunksLoadedBitset & (1L << getNeighbourIndex(relativeX, relativeZ)))
+            != 0;
     }
 
-    public final void setNeighbourLoaded(final int relativeX, final int relativeZ, final Chunk chunk) {
+    public final void setNeighbourLoaded(final int relativeX, final int relativeZ,
+        final Chunk chunk) {
         if (chunk == null) {
-            throw new IllegalArgumentException("Chunk must be non-null, neighbour: (" + relativeX + "," + relativeZ + "), chunk: " + this.loc);
+            throw new IllegalArgumentException(
+                "Chunk must be non-null, neighbour: (" + relativeX + "," + relativeZ + "), chunk: "
+                    + this.loc);
         }
         final int index = getNeighbourIndex(relativeX, relativeZ);
         this.loadedNeighbourChunks[index] = chunk;
@@ -213,7 +242,9 @@ public class Chunk implements IChunkAccess {
     // Tuinity end
 
     public Chunk(World world, ProtoChunk protochunk) {
-        this(world, protochunk.getPos(), protochunk.getBiomeIndex(), protochunk.p(), protochunk.n(), protochunk.o(), protochunk.getInhabitedTime(), protochunk.getSections(), (Consumer) null);
+        this(world, protochunk.getPos(), protochunk.getBiomeIndex(), protochunk.p(), protochunk.n(),
+            protochunk.o(), protochunk.getInhabitedTime(), protochunk.getSections(),
+            (Consumer) null);
         Iterator iterator = protochunk.y().iterator();
 
         while (iterator.hasNext()) {
@@ -256,33 +287,57 @@ public class Chunk implements IChunkAccess {
         this.needsDecoration = true; // CraftBukkit
     }
 
-    @Override
-    public HeightMap a(HeightMap.Type heightmap_type) {
+    @Override public HeightMap a(HeightMap.Type heightmap_type) {
         return (HeightMap) this.heightMap.computeIfAbsent(heightmap_type, (heightmap_type1) -> {
             return new HeightMap(this, heightmap_type1);
         });
     }
 
-    @Override
-    public Set<BlockPosition> c() {
+    @Override public Set<BlockPosition> c() {
         Set<BlockPosition> set = Sets.newHashSet(this.e.keySet());
 
         set.addAll(this.tileEntities.keySet());
         return set;
     }
 
-    @Override
-    public ChunkSection[] getSections() {
+    @Override public ChunkSection[] getSections() {
         return this.sections;
     }
 
     // Paper start - Optimize getBlockData to reduce instructions
-    public final IBlockData getBlockData(BlockPosition pos) { return getBlockData(pos.getX(), pos.getY(), pos.getZ()); } // Paper
+    public final IBlockData getBlockData(BlockPosition pos) {
+        return getBlockData(pos.getX(), pos.getY(), pos.getZ());
+    } // Paper
+
     public IBlockData getType(BlockPosition blockposition) {
         return this.getBlockData(blockposition.getX(), blockposition.getY(), blockposition.getZ());
     }
 
     public final IBlockData getBlockData(final int x, final int y, final int z) {
+        // Servett Start
+        try {
+            synchronized (world.tickingPlayerLock) {
+                if (world.tickingPlayer != null &&
+                    world.tickingPlayer.modifiedBlocks != null) {
+                    final PlayerBlockModification blockModification =
+                        world.tickingPlayer.modifiedBlocks.get(BlockPosition.at(x, y, z));
+                    if (blockModification != null) {
+                        return blockModification.getModifiedBlock();
+                    }
+                }
+            }
+        } catch (final Exception e) {
+            System.err.printf(
+                "FAILED TO READ PLAYER SPECIFIC BLOCK. TICKING PLAYER = %s. READING DEFAULT.\n",
+                world.tickingPlayer);
+            e.printStackTrace();
+        }
+        return getBlockDataInternal(x, y, z);
+        // Servett End
+    }
+
+    // Servett Start
+    public final IBlockData getBlockDataInternal(final int x, final int y, final int z) {
         // Method body / logic copied from below
         final int i = y >> 4;
         if (y >= 0 && i < this.sections.length && this.sections[i] != null) {
@@ -291,6 +346,7 @@ public class Chunk implements IChunkAccess {
         }
         return Blocks.AIR.getBlockData();
     }
+    // Servett End
 
     public IBlockData getBlockData_unused(int i, int j, int k) {
         // Paper end
@@ -319,7 +375,8 @@ public class Chunk implements IChunkAccess {
                 return Blocks.AIR.getBlockData();
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being got");
+                CrashReportSystemDetails crashreportsystemdetails =
+                    crashreport.a("Block being got");
 
                 crashreportsystemdetails.a("Location", () -> {
                     return CrashReportSystemDetails.a(i, j, k);
@@ -330,19 +387,16 @@ public class Chunk implements IChunkAccess {
     }
 
     // Paper start - If loaded util
-    @Override
-    public Fluid getFluidIfLoaded(BlockPosition blockposition) {
+    @Override public Fluid getFluidIfLoaded(BlockPosition blockposition) {
         return this.getFluid(blockposition);
     }
 
-    @Override
-    public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
+    @Override public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
         return this.getType(blockposition);
     }
     // Paper end
 
-    @Override
-    public Fluid getFluid(BlockPosition blockposition) {
+    @Override public Fluid getFluid(BlockPosition blockposition) {
         return this.a(blockposition.getX(), blockposition.getY(), blockposition.getZ());
     }
 
@@ -369,14 +423,14 @@ public class Chunk implements IChunkAccess {
     }
 
     // CraftBukkit start
-    @Nullable
-    @Override
-    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
+    @Nullable @Override public IBlockData setType(BlockPosition blockposition,
+        IBlockData iblockdata, boolean flag) {
         return this.setType(blockposition, iblockdata, flag, true);
     }
 
     @Nullable
-    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag, boolean doPlace) {
+    public IBlockData setType(BlockPosition blockposition, IBlockData iblockdata, boolean flag,
+        boolean doPlace) {
         // CraftBukkit end
         int i = blockposition.getX() & 15;
         int j = blockposition.getY();
@@ -388,7 +442,8 @@ public class Chunk implements IChunkAccess {
                 return null;
             }
 
-            chunksection = new ChunkSection(j >> 4 << 4, this, this.world, true); // Paper - Anti-Xray
+            chunksection =
+                new ChunkSection(world, j >> 4 << 4, this, this.world, true); // Paper - Anti-Xray
             this.sections[j >> 4] = chunksection;
         }
 
@@ -402,7 +457,8 @@ public class Chunk implements IChunkAccess {
             Block block1 = iblockdata1.getBlock();
 
             ((HeightMap) this.heightMap.get(HeightMap.Type.MOTION_BLOCKING)).a(i, j, k, iblockdata);
-            ((HeightMap) this.heightMap.get(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES)).a(i, j, k, iblockdata);
+            ((HeightMap) this.heightMap.get(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES))
+                .a(i, j, k, iblockdata);
             ((HeightMap) this.heightMap.get(HeightMap.Type.OCEAN_FLOOR)).a(i, j, k, iblockdata);
             ((HeightMap) this.heightMap.get(HeightMap.Type.WORLD_SURFACE)).a(i, j, k, iblockdata);
             boolean flag2 = chunksection.c();
@@ -430,7 +486,8 @@ public class Chunk implements IChunkAccess {
                 }
 
                 // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
-                if (!this.world.isClientSide && doPlace && (!this.world.captureBlockStates || block instanceof BlockTileEntity)) {
+                if (!this.world.isClientSide && doPlace && (!this.world.captureBlockStates
+                    || block instanceof BlockTileEntity)) {
                     iblockdata.onPlace(this.world, blockposition, iblockdata1, flag);
                 }
 
@@ -450,20 +507,19 @@ public class Chunk implements IChunkAccess {
         }
     }
 
-    @Nullable
-    public LightEngine e() {
+    @Nullable public LightEngine e() {
         return this.world.getChunkProvider().getLightEngine();
     }
 
-    @Override
-    public void a(Entity entity) {
+    @Override public void a(Entity entity) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async addEntity call"); // Tuinity
         this.q = true;
         int i = MathHelper.floor(entity.locX() / 16.0D);
         int j = MathHelper.floor(entity.locZ() / 16.0D);
 
         if (i != this.loc.x || j != this.loc.z) {
-            Chunk.LOGGER.warn("Wrong location! ({}, {}) should be ({}, {}), {}", i, j, this.loc.x, this.loc.z, entity);
+            Chunk.LOGGER.warn("Wrong location! ({}, {}) should be ({}, {}), {}", i, j, this.loc.x,
+                this.loc.z, entity);
             entity.dead = true;
             return; // Paper
         }
@@ -481,23 +537,29 @@ public class Chunk implements IChunkAccess {
         List<Entity> nextSlice = this.entitySlices[k]; // the next list to be added to
         List<Entity> currentSlice = entity.entitySlice;
         if (nextSlice == currentSlice) {
-            if (World.DEBUG_ENTITIES) MinecraftServer.LOGGER.warn("Entity was already in this chunk!" + entity, new Throwable());
+            if (World.DEBUG_ENTITIES)
+                MinecraftServer.LOGGER
+                    .warn("Entity was already in this chunk!" + entity, new Throwable());
             return; // ??? silly plugins
         }
         if (currentSlice != null && currentSlice.contains(entity)) {
             // Still in an old chunk...
-            if (World.DEBUG_ENTITIES) MinecraftServer.LOGGER.warn("Entity is still in another chunk!" + entity, new Throwable());
+            if (World.DEBUG_ENTITIES)
+                MinecraftServer.LOGGER
+                    .warn("Entity is still in another chunk!" + entity, new Throwable());
             Chunk chunk = entity.getCurrentChunk();
             if (chunk != null) {
                 chunk.removeEntity(entity);
             } else {
                 removeEntity(entity);
             }
-            currentSlice.remove(entity); // Just incase the above did not remove from the previous slice
+            currentSlice
+                .remove(entity); // Just incase the above did not remove from the previous slice
         }
         // Paper end
 
-        if (!entity.inChunk || entity.getCurrentChunk() != this) entityCounts.increment(entity.getMinecraftKeyString()); // Paper
+        if (!entity.inChunk || entity.getCurrentChunk() != this)
+            entityCounts.increment(entity.getMinecraftKeyString()); // Paper
         entity.inChunk = true;
         entity.setCurrentChunk(this); // Paper
         entity.chunkX = this.loc.x;
@@ -516,18 +578,21 @@ public class Chunk implements IChunkAccess {
         this.markDirty(); // Paper
     }
 
-    @Override
-    public void a(HeightMap.Type heightmap_type, long[] along) {
+    @Override public void a(HeightMap.Type heightmap_type, long[] along) {
         ((HeightMap) this.heightMap.get(heightmap_type)).a(along);
     }
 
-    public void removeEntity(Entity entity) { this.b(entity); } // Paper - OBFHELPER
+    public void removeEntity(Entity entity) {
+        this.b(entity);
+    } // Paper - OBFHELPER
+
     public void b(Entity entity) {
         this.a(entity, entity.chunkY);
     }
 
     public void a(Entity entity, int i) {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async removeEntity call"); // Tuinity
+        com.tuinity.tuinity.util.TickThread
+            .softEnsureTickThread("Async removeEntity call"); // Tuinity
         if (i < 0) {
             i = 0;
         }
@@ -537,7 +602,8 @@ public class Chunk implements IChunkAccess {
         }
 
         // Paper start
-        if (entity.currentChunk != null && entity.currentChunk.get() == this) entity.setCurrentChunk(null);
+        if (entity.currentChunk != null && entity.currentChunk.get() == this)
+            entity.setCurrentChunk(null);
         if (entitySlices[i] == entity.entitySlice) {
             entity.entitySlice = null;
         }
@@ -555,7 +621,10 @@ public class Chunk implements IChunkAccess {
         this.entities.remove(entity); // Paper
     }
 
-    public int getHighestBlockY(HeightMap.Type heightmap_type, int i, int j) { return this.a(heightmap_type, i, j) + 1; } // Paper - sort of an obfhelper, but without -1
+    public int getHighestBlockY(HeightMap.Type heightmap_type, int i, int j) {
+        return this.a(heightmap_type, i, j) + 1;
+    } // Paper - sort of an obfhelper, but without -1
+
     @Override public int a(HeightMap.Type heightmap_type, int i, int j) { // Paper
         return ((HeightMap) this.heightMap.get(heightmap_type)).a(i & 15, j & 15) - 1;
     }
@@ -566,23 +635,23 @@ public class Chunk implements IChunkAccess {
     }
     // Tuinity end
 
-    @Nullable
-    private TileEntity j(BlockPosition blockposition) {
+    @Nullable private TileEntity j(BlockPosition blockposition) {
         IBlockData iblockdata = this.getType(blockposition);
         Block block = iblockdata.getBlock();
 
         return !block.isTileEntity() ? null : ((ITileEntity) block).createTile(this.world);
     }
 
-    @Nullable
-    @Override
-    public TileEntity getTileEntity(BlockPosition blockposition) {
+    @Nullable @Override public TileEntity getTileEntity(BlockPosition blockposition) {
         return this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
     }
 
-    @Nullable public final TileEntity getTileEntityImmediately(BlockPosition pos) { return this.a(pos, EnumTileEntityState.IMMEDIATE); } // Paper - OBFHELPER
-    @Nullable
-    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+    @Nullable public final TileEntity getTileEntityImmediately(BlockPosition pos) {
+        return this.a(pos, EnumTileEntityState.IMMEDIATE);
+    } // Paper - OBFHELPER
+
+    @Nullable public TileEntity a(BlockPosition blockposition,
+        Chunk.EnumTileEntityState chunk_enumtileentitystate) {
         // CraftBukkit start
         TileEntity tileentity = world.capturedTileEntities.get(blockposition);
         if (tileentity == null) {
@@ -623,12 +692,12 @@ public class Chunk implements IChunkAccess {
 
     }
 
-    @Override
-    public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {
+    @Override public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {
         if (this.getType(blockposition).getBlock() instanceof ITileEntity) {
             tileentity.setLocation(this.world, blockposition);
             tileentity.r();
-            TileEntity tileentity1 = (TileEntity) this.tileEntities.put(blockposition.immutableCopy(), tileentity);
+            TileEntity tileentity1 =
+                (TileEntity) this.tileEntities.put(blockposition.immutableCopy(), tileentity);
 
             if (tileentity1 != null && tileentity1 != tileentity) {
                 tileentity1.ab_();
@@ -636,16 +705,18 @@ public class Chunk implements IChunkAccess {
 
             // CraftBukkit start
             // Paper start - Remove invalid mob spawner tile entities
-        } else if (tileentity instanceof TileEntityMobSpawner && !(getBlockData(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getBlock() instanceof BlockMobSpawner)) {
+        } else if (tileentity instanceof TileEntityMobSpawner && !(getBlockData(
+            blockposition.getX(), blockposition.getY(), blockposition.getZ())
+            .getBlock() instanceof BlockMobSpawner)) {
             this.tileEntities.remove(blockposition);
             // Paper end
         } else {
             // Paper start
             ServerInternalException e = new ServerInternalException(
-                    "Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position.getX() + ","
-                            + tileentity.position.getY() + "," + tileentity.position.getZ()
-                            + " (" + getType(blockposition) + ") where there was no entity tile!\n" +
-                            "Chunk coordinates: " + (this.loc.x * 16) + "," + (this.loc.z * 16));
+                "Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position
+                    .getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ()
+                    + " (" + getType(blockposition) + ") where there was no entity tile!\n"
+                    + "Chunk coordinates: " + (this.loc.x * 16) + "," + (this.loc.z * 16));
             e.printStackTrace();
             ServerInternalException.reportInternalException(e);
 
@@ -659,14 +730,12 @@ public class Chunk implements IChunkAccess {
         }
     }
 
-    @Override
-    public void a(NBTTagCompound nbttagcompound) {
-        this.e.put(new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z")), nbttagcompound);
+    @Override public void a(NBTTagCompound nbttagcompound) {
+        this.e.put(new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"),
+            nbttagcompound.getInt("z")), nbttagcompound);
     }
 
-    @Nullable
-    @Override
-    public NBTTagCompound i(BlockPosition blockposition) {
+    @Nullable @Override public NBTTagCompound i(BlockPosition blockposition) {
         TileEntity tileentity = this.getTileEntity(blockposition);
         NBTTagCompound nbttagcompound;
 
@@ -685,8 +754,7 @@ public class Chunk implements IChunkAccess {
         }
     }
 
-    @Override
-    public void removeTileEntity(BlockPosition blockposition) {
+    @Override public void removeTileEntity(BlockPosition blockposition) {
         if (this.loaded || this.world.p_()) {
             TileEntity tileentity = (TileEntity) this.tileEntities.remove(blockposition);
 
@@ -710,10 +778,11 @@ public class Chunk implements IChunkAccess {
         // Tuinity start - neighbour cache
         int chunkX = this.loc.x;
         int chunkZ = this.loc.z;
-        ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();
+        ChunkProviderServer chunkProvider = ((WorldServer) this.world).getChunkProvider();
         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
-                Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                Chunk neighbour =
+                    chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
                 if (neighbour != null) {
                     neighbour.setNeighbourLoaded(-dx, -dz, this);
                     // should be in cached already
@@ -724,38 +793,43 @@ public class Chunk implements IChunkAccess {
         this.loadedTicketLevel = true;
         // Tuinity end - neighbour cache
 
-        ((WorldServer)this.world).onChunkLoad(this); // Tuinity - optimise entity list iteration
+        ((WorldServer) this.world).onChunkLoad(this); // Tuinity - optimise entity list iteration
         org.bukkit.Server server = this.world.getServer();
-        ((WorldServer)this.world).getChunkProvider().addLoadedChunk(this); // Paper
+        ((WorldServer) this.world).getChunkProvider().addLoadedChunk(this); // Paper
         if (server != null) {
             /*
              * If it's a new world, the first few chunks are generated inside
              * the World constructor. We can't reliably alter that, so we have
              * no way of creating a CraftWorld/CraftServer at that point.
              */
-            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
+            server.getPluginManager().callEvent(
+                new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
 
             if (this.needsDecoration) {
-                try (co.aikar.timings.Timing ignored = this.world.timings.syncChunkLoadPopulateTimer.startTiming()) { // Paper
-                this.needsDecoration = false;
-                java.util.Random random = new java.util.Random();
-                random.setSeed(world.getSeed());
-                long xRand = random.nextLong() / 2L * 2L + 1L;
-                long zRand = random.nextLong() / 2L * 2L + 1L;
-                random.setSeed((long) this.loc.x * xRand + (long) this.loc.z * zRand ^ world.getSeed());
-
-                org.bukkit.World world = this.world.getWorld();
-                if (world != null) {
-                    this.world.populating = true;
-                    try {
-                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
-                            populator.populate(world, random, bukkitChunk);
+                try (co.aikar.timings.Timing ignored = this.world.timings.syncChunkLoadPopulateTimer
+                    .startTiming()) { // Paper
+                    this.needsDecoration = false;
+                    java.util.Random random = new java.util.Random();
+                    random.setSeed(world.getSeed());
+                    long xRand = random.nextLong() / 2L * 2L + 1L;
+                    long zRand = random.nextLong() / 2L * 2L + 1L;
+                    random.setSeed(
+                        (long) this.loc.x * xRand + (long) this.loc.z * zRand ^ world.getSeed());
+
+                    org.bukkit.World world = this.world.getWorld();
+                    if (world != null) {
+                        this.world.populating = true;
+                        try {
+                            for (org.bukkit.generator.BlockPopulator populator : world
+                                .getPopulators()) {
+                                populator.populate(world, random, bukkitChunk);
+                            }
+                        } finally {
+                            this.world.populating = false;
                         }
-                    } finally {
-                        this.world.populating = false;
                     }
-                }
-                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+                    server.getPluginManager()
+                        .callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
                 } // Paper
             }
         }
@@ -763,18 +837,20 @@ public class Chunk implements IChunkAccess {
 
     public void unloadCallback() {
         org.bukkit.Server server = this.world.getServer();
-        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isNeedsSaving());
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent =
+            new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isNeedsSaving());
         server.getPluginManager().callEvent(unloadEvent);
         // note: saving can be prevented, but not forced if no saving is actually required
         this.mustNotSave = !unloadEvent.isSaveChunk();
-        ((WorldServer)this.world).getChunkProvider().removeLoadedChunk(this); // Paper
+        ((WorldServer) this.world).getChunkProvider().removeLoadedChunk(this); // Paper
         // Tuinity start - neighbour cache
         int chunkX = this.loc.x;
         int chunkZ = this.loc.z;
-        ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();
+        ChunkProviderServer chunkProvider = ((WorldServer) this.world).getChunkProvider();
         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
-                Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                Chunk neighbour =
+                    chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
                 if (neighbour != null) {
                     neighbour.setNeighbourUnloaded(-dx, -dz);
                 }
@@ -784,7 +860,7 @@ public class Chunk implements IChunkAccess {
         this.resetNeighbours();
         // Tuinity end - neighbour cache
 
-        ((WorldServer)this.world).onChunkUnload(this); // Tuinity - optimise entity list iteration
+        ((WorldServer) this.world).onChunkUnload(this); // Tuinity - optimise entity list iteration
     }
     // CraftBukkit end
 
@@ -792,8 +868,10 @@ public class Chunk implements IChunkAccess {
         this.s = true;
     }
 
-    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, @Nullable Predicate<? super Entity> predicate) {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async getEntities call"); // Tuinity
+    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list,
+        @Nullable Predicate<? super Entity> predicate) {
+        com.tuinity.tuinity.util.TickThread
+            .softEnsureTickThread("Async getEntities call"); // Tuinity
         int i = MathHelper.floor((axisalignedbb.minY - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.maxY + 2.0D) / 16.0D);
 
@@ -806,7 +884,8 @@ public class Chunk implements IChunkAccess {
 
                 while (iterator.hasNext()) {
                     Entity entity1 = (Entity) iterator.next();
-                    if (entity1.shouldBeRemoved) continue; // Paper
+                    if (entity1.shouldBeRemoved)
+                        continue; // Paper
 
                     if (entity1.getBoundingBox().c(axisalignedbb) && entity1 != entity) {
                         if (predicate == null || predicate.test(entity1)) {
@@ -814,13 +893,16 @@ public class Chunk implements IChunkAccess {
                         }
 
                         if (entity1 instanceof EntityEnderDragon) {
-                            EntityComplexPart[] aentitycomplexpart = ((EntityEnderDragon) entity1).eo();
+                            EntityComplexPart[] aentitycomplexpart =
+                                ((EntityEnderDragon) entity1).eo();
                             int l = aentitycomplexpart.length;
 
                             for (int i1 = 0; i1 < l; ++i1) {
                                 EntityComplexPart entitycomplexpart = aentitycomplexpart[i1];
 
-                                if (entitycomplexpart != entity && entitycomplexpart.getBoundingBox().c(axisalignedbb) && (predicate == null || predicate.test(entitycomplexpart))) {
+                                if (entitycomplexpart != entity && entitycomplexpart
+                                    .getBoundingBox().c(axisalignedbb) && (predicate == null
+                                    || predicate.test(entitycomplexpart))) {
                                     list.add(entitycomplexpart);
                                 }
                             }
@@ -832,8 +914,10 @@ public class Chunk implements IChunkAccess {
 
     }
 
-    public <T extends Entity> void a(@Nullable EntityTypes<?> entitytypes, AxisAlignedBB axisalignedbb, List<? super T> list, Predicate<? super T> predicate) {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async getEntities call"); // Tuinity
+    public <T extends Entity> void a(@Nullable EntityTypes<?> entitytypes,
+        AxisAlignedBB axisalignedbb, List<? super T> list, Predicate<? super T> predicate) {
+        com.tuinity.tuinity.util.TickThread
+            .softEnsureTickThread("Async getEntities call"); // Tuinity
         int i = MathHelper.floor((axisalignedbb.minY - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.maxY + 2.0D) / 16.0D);
 
@@ -845,9 +929,11 @@ public class Chunk implements IChunkAccess {
 
             while (iterator.hasNext()) {
                 T entity = (T) iterator.next(); // CraftBukkit - decompile error
-                if (entity.shouldBeRemoved) continue; // Paper
+                if (entity.shouldBeRemoved)
+                    continue; // Paper
 
-                if ((entitytypes == null || entity.getEntityType() == entitytypes) && entity.getBoundingBox().c(axisalignedbb) && predicate.test(entity)) {
+                if ((entitytypes == null || entity.getEntityType() == entitytypes) && entity
+                    .getBoundingBox().c(axisalignedbb) && predicate.test(entity)) {
                     list.add(entity);
                 }
             }
@@ -855,8 +941,10 @@ public class Chunk implements IChunkAccess {
 
     }
 
-    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, List<T> list, @Nullable Predicate<? super T> predicate) {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async getEntities call"); // Tuinity
+    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb,
+        List<T> list, @Nullable Predicate<? super T> predicate) {
+        com.tuinity.tuinity.util.TickThread
+            .softEnsureTickThread("Async getEntities call"); // Tuinity
         int i = MathHelper.floor((axisalignedbb.minY - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.maxY + 2.0D) / 16.0D);
 
@@ -874,7 +962,8 @@ public class Chunk implements IChunkAccess {
         }
         // Paper end
         for (int k = i; k <= j; ++k) {
-            if (counts != null && counts[k] <= 0) continue; // Paper - Don't check a chunk if it doesn't have the type we are looking for
+            if (counts != null && counts[k] <= 0)
+                continue; // Paper - Don't check a chunk if it doesn't have the type we are looking for
             Iterator iterator = this.entitySlices[k].iterator(); // Spigot
 
             // Paper start - Don't search for inventories if we have none, and that is all we want
@@ -884,13 +973,16 @@ public class Chunk implements IChunkAccess {
              * Make sure the inventory selector stays in sync.
              * It should be the one that checks `var1 instanceof IInventory && var1.isAlive()`
              */
-            if (predicate == IEntitySelector.isInventory() && inventoryEntityCounts[k] <= 0) continue;
+            if (predicate == IEntitySelector.isInventory() && inventoryEntityCounts[k] <= 0)
+                continue;
             // Paper end
             while (iterator.hasNext()) {
                 T t0 = (T) iterator.next(); // CraftBukkit - decompile error
-                if (t0.shouldBeRemoved) continue; // Paper
+                if (t0.shouldBeRemoved)
+                    continue; // Paper
 
-                if (oclass.isInstance(t0) && t0.getBoundingBox().c(axisalignedbb) && (predicate == null || predicate.test(t0))) { // Spigot - instance check
+                if (oclass.isInstance(t0) && t0.getBoundingBox().c(axisalignedbb) && (
+                    predicate == null || predicate.test(t0))) { // Spigot - instance check
                     list.add(t0);
                 }
             }
@@ -902,13 +994,11 @@ public class Chunk implements IChunkAccess {
         return false;
     }
 
-    @Override
-    public ChunkCoordIntPair getPos() {
+    @Override public ChunkCoordIntPair getPos() {
         return this.loc;
     }
 
-    @Override
-    public BiomeStorage getBiomeIndex() {
+    @Override public BiomeStorage getBiomeIndex() {
         return this.d;
     }
 
@@ -920,8 +1010,7 @@ public class Chunk implements IChunkAccess {
         return this.world;
     }
 
-    @Override
-    public Collection<Entry<HeightMap.Type, HeightMap>> f() {
+    @Override public Collection<Entry<HeightMap.Type, HeightMap>> f() {
         return Collections.unmodifiableSet(this.heightMap.entrySet());
     }
 
@@ -933,101 +1022,88 @@ public class Chunk implements IChunkAccess {
         return this.entitySlices;
     }
 
-    @Override
-    public NBTTagCompound f(BlockPosition blockposition) {
+    @Override public NBTTagCompound f(BlockPosition blockposition) {
         return (NBTTagCompound) this.e.get(blockposition);
     }
 
-    @Override
-    public Stream<BlockPosition> m() {
-        return StreamSupport.stream(BlockPosition.b(this.loc.d(), 0, this.loc.e(), this.loc.f(), 255, this.loc.g()).spliterator(), false).filter((blockposition) -> {
+    @Override public Stream<BlockPosition> m() {
+        return StreamSupport.stream(
+            BlockPosition.b(this.loc.d(), 0, this.loc.e(), this.loc.f(), 255, this.loc.g())
+                .spliterator(), false).filter((blockposition) -> {
             return this.getType(blockposition).h() != 0;
         });
     }
 
-    @Override
-    public TickList<Block> n() {
+    @Override public TickList<Block> n() {
         return this.o;
     }
 
-    @Override
-    public TickList<FluidType> o() {
+    @Override public TickList<FluidType> o() {
         return this.p;
     }
 
-    @Override
-    public void setNeedsSaving(boolean flag) {
+    @Override public void setNeedsSaving(boolean flag) {
         this.s = flag;
     }
 
-    @Override
-    public boolean isNeedsSaving() {
-        return (this.s || this.q && this.world.getTime() != this.lastSaved) && !this.mustNotSave; // CraftBukkit
+    @Override public boolean isNeedsSaving() {
+        return (this.s || this.q && this.world.getTime() != this.lastSaved)
+            && !this.mustNotSave; // CraftBukkit
     }
 
     public void d(boolean flag) {
         this.q = flag;
     }
 
-    @Override
-    public void setLastSaved(long i) {
+    @Override public void setLastSaved(long i) {
         this.lastSaved = i;
     }
 
-    @Nullable
-    @Override
-    public StructureStart a(String s) {
+    @Nullable @Override public StructureStart a(String s) {
         return (StructureStart) this.l.get(s);
     }
 
-    @Override
-    public void a(String s, StructureStart structurestart) {
+    @Override public void a(String s, StructureStart structurestart) {
         this.l.put(s, structurestart);
     }
 
-    @Override
-    public Map<String, StructureStart> h() {
+    @Override public Map<String, StructureStart> h() {
         return this.l;
     }
 
-    @Override
-    public void a(Map<String, StructureStart> map) {
+    @Override public void a(Map<String, StructureStart> map) {
         this.l.clear();
         this.l.putAll(map);
     }
 
-    @Override
-    public LongSet b(String s) {
+    @Override public LongSet b(String s) {
         return (LongSet) this.m.computeIfAbsent(s, (s1) -> {
             return new LongOpenHashSet();
         });
     }
 
-    @Override
-    public void a(String s, long i) {
+    @Override public void a(String s, long i) {
         ((LongSet) this.m.computeIfAbsent(s, (s1) -> {
             return new LongOpenHashSet();
         })).add(i);
     }
 
-    @Override
-    public Map<String, LongSet> v() {
+    @Override public Map<String, LongSet> v() {
         return this.m;
     }
 
-    @Override
-    public void b(Map<String, LongSet> map) {
+    @Override public void b(Map<String, LongSet> map) {
         this.m.clear();
         this.m.putAll(map);
     }
 
-    @Override
-    public long getInhabitedTime() {
-        return world.paperConfig.fixedInhabitedTime < 0 ? this.inhabitedTime : world.paperConfig.fixedInhabitedTime; // Paper
+    @Override public long getInhabitedTime() {
+        return world.paperConfig.fixedInhabitedTime < 0 ?
+            this.inhabitedTime :
+            world.paperConfig.fixedInhabitedTime; // Paper
     }
 
-    @Override
-    public void setInhabitedTime(long i) {
+    @Override public void setInhabitedTime(long i) {
         this.inhabitedTime = i;
     }
 
@@ -1042,7 +1118,8 @@ public class Chunk implements IChunkAccess {
                     Short oshort = (Short) shortlistiterator.next();
                     BlockPosition blockposition = ProtoChunk.a(oshort, i, chunkcoordintpair);
                     IBlockData iblockdata = this.getType(blockposition);
-                    IBlockData iblockdata1 = Block.b(iblockdata, (GeneratorAccess) this.world, blockposition);
+                    IBlockData iblockdata1 =
+                        Block.b(iblockdata, (GeneratorAccess) this.world, blockposition);
 
                     this.world.setTypeAndData(blockposition, iblockdata1, 20);
                 }
@@ -1064,8 +1141,7 @@ public class Chunk implements IChunkAccess {
         this.i.a(this);
     }
 
-    @Nullable
-    private TileEntity a(BlockPosition blockposition, NBTTagCompound nbttagcompound) {
+    @Nullable private TileEntity a(BlockPosition blockposition, NBTTagCompound nbttagcompound) {
         TileEntity tileentity;
 
         if ("DUMMY".equals(nbttagcompound.getString("id"))) {
@@ -1075,7 +1151,9 @@ public class Chunk implements IChunkAccess {
                 tileentity = ((ITileEntity) block).createTile(this.world);
             } else {
                 tileentity = null;
-                Chunk.LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", blockposition, this.getType(blockposition));
+                Chunk.LOGGER.warn(
+                    "Tried to load a DUMMY block entity @ {} but found not block entity block {} at location",
+                    blockposition, this.getType(blockposition));
             }
         } else {
             tileentity = TileEntity.create(nbttagcompound);
@@ -1085,27 +1163,27 @@ public class Chunk implements IChunkAccess {
             tileentity.setLocation(this.world, blockposition);
             this.a(tileentity);
         } else {
-            Chunk.LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", this.getType(blockposition), blockposition);
+            Chunk.LOGGER.warn("Tried to load a block entity for block {} but failed at location {}",
+                this.getType(blockposition), blockposition);
         }
 
         return tileentity;
     }
 
-    @Override
-    public ChunkConverter p() {
+    @Override public ChunkConverter p() {
         return this.i;
     }
 
-    @Override
-    public ShortList[] l() {
+    @Override public ShortList[] l() {
         return this.n;
     }
 
     public void B() {
         if (this.o instanceof ProtoChunkTickList) {
-            ((ProtoChunkTickList<Block>) this.o).a(this.world.getBlockTickList(), (blockposition) -> { // CraftBukkit - decompile error
-                return this.getType(blockposition).getBlock();
-            });
+            ((ProtoChunkTickList<Block>) this.o).a(this.world.getBlockTickList(),
+                (blockposition) -> { // CraftBukkit - decompile error
+                    return this.getType(blockposition).getBlock();
+                });
             this.o = TickListEmpty.b();
         } else if (this.o instanceof TickListChunk) {
             this.world.getBlockTickList().a(((TickListChunk) this.o).b());
@@ -1113,9 +1191,10 @@ public class Chunk implements IChunkAccess {
         }
 
         if (this.p instanceof ProtoChunkTickList) {
-            ((ProtoChunkTickList<FluidType>) this.p).a(this.world.getFluidTickList(), (blockposition) -> { // CraftBukkit - decompile error
-                return this.getFluid(blockposition).getType();
-            });
+            ((ProtoChunkTickList<FluidType>) this.p).a(this.world.getFluidTickList(),
+                (blockposition) -> { // CraftBukkit - decompile error
+                    return this.getFluid(blockposition).getType();
+                });
             this.p = TickListEmpty.b();
         } else if (this.p instanceof TickListChunk) {
             this.world.getFluidTickList().a(((TickListChunk) this.p).b());
@@ -1126,19 +1205,20 @@ public class Chunk implements IChunkAccess {
 
     public void a(WorldServer worldserver) {
         if (this.o == TickListEmpty.<Block>b()) { // CraftBukkit - decompile error
-            this.o = new TickListChunk<>(IRegistry.BLOCK::getKey, worldserver.getBlockTickList().a(this.loc, true, false));
+            this.o = new TickListChunk<>(IRegistry.BLOCK::getKey,
+                worldserver.getBlockTickList().a(this.loc, true, false));
             this.setNeedsSaving(true);
         }
 
         if (this.p == TickListEmpty.<FluidType>b()) { // CraftBukkit - decompile error
-            this.p = new TickListChunk<>(IRegistry.FLUID::getKey, worldserver.getFluidTickList().a(this.loc, true, false));
+            this.p = new TickListChunk<>(IRegistry.FLUID::getKey,
+                worldserver.getFluidTickList().a(this.loc, true, false));
             this.setNeedsSaving(true);
         }
 
     }
 
-    @Override
-    public ChunkStatus getChunkStatus() {
+    @Override public ChunkStatus getChunkStatus() {
         return ChunkStatus.FULL;
     }
 
@@ -1150,13 +1230,11 @@ public class Chunk implements IChunkAccess {
         this.u = supplier;
     }
 
-    @Override
-    public boolean r() {
+    @Override public boolean r() {
         return this.x;
     }
 
-    @Override
-    public void b(boolean flag) {
+    @Override public void b(boolean flag) {
         this.x = flag;
         this.setNeedsSaving(true);
     }
@@ -1165,6 +1243,52 @@ public class Chunk implements IChunkAccess {
 
         IMMEDIATE, QUEUED, CHECK;
 
-        private EnumTileEntityState() {}
+        private EnumTileEntityState() {
+        }
+    }
+
+
+    // Servett Start
+    public void addPlayerModifiedBlock(final int x, final int y, final int z,
+        final EntityPlayer entityPlayer, final IBlockData blockData) {
+        final long position = BlockPosition.at(x, y, z);
+        entityPlayer.modifiedBlocks
+            .put(position, new PlayerBlockModification(entityPlayer.getId(), blockData));
     }
+
+    public void removePlayerModifiedBlock(int x, int y, int z, EntityPlayer entityPlayer) {
+        final long position = BlockPosition.at(x, y, z);
+        entityPlayer.modifiedBlocks.remove(position);
+    }
+
+    public static class PlayerBlockModification {
+
+        private final int playerID;
+        private final IBlockData modifiedBlock;
+
+        private PlayerBlockModification(final int playerID, final IBlockData modifiedBlock) {
+            this.playerID = playerID;
+            this.modifiedBlock = modifiedBlock;
+        }
+
+        public int getPlayerID() {
+            return this.playerID;
+        }
+
+        public IBlockData getModifiedBlock() {
+            return this.modifiedBlock;
+        }
+    }
+
+    @Override public IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        final PlayerBlockModification playerBlockModification =
+            tickingPlayer.modifiedBlocks.get(position.asLong());
+        if (playerBlockModification != null) {
+            return playerBlockModification.getModifiedBlock();
+        } else {
+            return getBlockDataInternal(position.x, position.y, position.z);
+        }
+    }
+    // Servett End
+
 }
diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
index 29c66b983dc503903a76bab753bb9035ec10f54c..5eb0146aee59f5ec1a43a8203193efcb6377133f 100644
--- a/src/main/java/net/minecraft/server/ChunkCache.java
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -95,11 +95,21 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
 
     @Override
     public IBlockData getType(BlockPosition blockposition) {
+        // Servett Start
+        synchronized (e.tickingPlayerLock) {
+            if (e.tickingPlayer != null) {
+                final Chunk.PlayerBlockModification playerBlockModification =
+                    e.tickingPlayer.modifiedBlocks.get(blockposition.asLong());
+                if (playerBlockModification != null) {
+                    return playerBlockModification.getModifiedBlock();
+                }
+            }
+        }
+        // Servett End
         if (World.isOutsideWorld(blockposition)) {
             return Blocks.AIR.getBlockData();
         } else {
             IChunkAccess ichunkaccess = this.d(blockposition);
-
             return ichunkaccess.getType(blockposition);
         }
     }
@@ -114,4 +124,22 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
             return ichunkaccess.getFluid(blockposition);
         }
     }
+
+    // Servett Start
+    @Override
+    public IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        final Chunk.PlayerBlockModification playerBlockModification =
+            tickingPlayer.modifiedBlocks.get(position.asLong());
+        if (playerBlockModification != null) {
+            return playerBlockModification.getModifiedBlock();
+        }
+        if (World.isOutsideWorld(position)) {
+            return Blocks.AIR.getBlockData();
+        } else {
+            IChunkAccess ichunkaccess = this.d(position);
+            return ichunkaccess.getType(position);
+        }
+    }
+    // Servett End
+
 }
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index d529b795c5434328a81c015558708b4994203099..9e8a8482e17a54c6878b469ac3297b300c08b460 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -1,23 +1,23 @@
 package net.minecraft.server;
 
-import co.aikar.timings.Timings;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.ArrayDeque; // Paper
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.function.Function;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 public class ChunkRegionLoader {
 
@@ -97,7 +97,7 @@ public class ChunkRegionLoader {
             byte b0 = nbttagcompound2.getByte("Y");
 
             if (nbttagcompound2.hasKeyOfType("Palette", 9) && nbttagcompound2.hasKeyOfType("BlockStates", 12)) {
-                ChunkSection chunksection = new ChunkSection(b0 << 4, null, worldserver, false); // Paper - Anti-Xray
+                ChunkSection chunksection = new ChunkSection(worldserver, b0 << 4, null, worldserver, false); // Paper - Anti-Xray // Servett: Add world
 
                 chunksection.getBlocks().a(nbttagcompound2.getList("Palette", 10), nbttagcompound2.getLongArray("BlockStates"));
                 chunksection.recalcBlockCounts();
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 8b28fb5ee13860ed16df6838d0ed50016a3e4caf..0ef59986acdbeac51f9c7e0b9bb6068c572d9426 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -10,24 +10,25 @@ public class ChunkSection {
     short tickingBlockCount; // Paper - private -> package-private
     private short e;
     final DataPaletteBlock<IBlockData> blockIds;
+    private final World world; // Servett
 
     Chunk chunk; // Paper
     final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
-    public ChunkSection(int i) {
+    public ChunkSection(World world, int i) { // Servett: Add world
         // Paper start - add parameters
-        this(i, (IChunkAccess)null, (IWorldReader)null, true);
+        this(world, i, (IChunkAccess)null, (IWorldReader)null, true);
     }
-    public ChunkSection(int i, IChunkAccess chunk, IWorldReader world, boolean initializeBlocks) {
-        this(i, (short) 0, (short) 0, (short) 0, chunk, world, initializeBlocks);
+    public ChunkSection(World worldObject, int i, IChunkAccess chunk, IWorldReader world, boolean initializeBlocks) { // Servett: Add world
+        this(worldObject, i, (short) 0, (short) 0, (short) 0, chunk, world, initializeBlocks);
         // Paper end
     }
 
-    public ChunkSection(int i, short short0, short short1, short short2) {
+    public ChunkSection(World world, int i, short short0, short short1, short short2) { // Servett: Add world
         // Paper start - add parameters
-        this(i, short0, short1, short2, (IChunkAccess)null, (IWorldReader)null, true);
+        this(world, i, short0, short1, short2, (IChunkAccess)null, (IWorldReader)null, true);
     }
-    public ChunkSection(int i, short short0, short short1, short short2, IChunkAccess chunk, IWorldReader world, boolean initializeBlocks) {
+    public ChunkSection(World worldObject, int i, short short0, short short1, short short2, IChunkAccess chunk, IWorldReader world, boolean initializeBlocks) { // Servett: Add world
         // Paper end
         this.yPos = i;
         this.nonEmptyBlockCount = short0;
@@ -39,9 +40,31 @@ public class ChunkSection {
             this.chunk = (Chunk)chunk;
         }
         // Paper end
+        // Servett Start
+        this.world = worldObject;
+        // Servett end
     }
 
     public IBlockData getType(int i, int j, int k) {
+        if (this.world != null) {
+            synchronized (world.tickingPlayerLock) {
+                if (world.tickingPlayer != null) {
+                    final Chunk.PlayerBlockModification playerBlockModification =
+                        world.tickingPlayer.modifiedBlocks.get(BlockPosition.at(i, j, k));
+                    if (playerBlockModification != null) {
+                        return playerBlockModification.getModifiedBlock();
+                    }
+                }
+            }
+        } else {
+            synchronized (EntityPlayer.tickingPlayerLock) {
+                final Chunk.PlayerBlockModification playerBlockModification = EntityPlayer.tickingPlayer
+                    .modifiedBlocks.get(BlockPosition.at(i, j, k));
+                if (playerBlockModification != null) {
+                    return playerBlockModification.getModifiedBlock();
+                }
+            }
+        }
         return (IBlockData) this.blockIds.a(i, j, k);
     }
 
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index e1b03012776f201d30566e91956e25d66e44f5f7..3f5a1d4f32abccd32761285c0d749393e78f243a 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -4,20 +4,8 @@ import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
-import io.netty.util.concurrent.Future;
-import java.util.ArrayDeque; // Paper
-import java.util.Collection;
-import java.util.Deque; // Paper
-import java.util.Iterator;
-import java.util.List;
-import java.util.OptionalInt;
-import java.util.Random;
-import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import com.google.common.base.Preconditions;
 import org.bukkit.Bukkit;
 import org.bukkit.GameMode;
 import org.bukkit.Location;
@@ -35,11 +23,30 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+
+import javax.annotation.Nullable;
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.OptionalInt;
+import java.util.Random;
+
+// CraftBukkit start
 // CraftBukkit end
 
 public class EntityPlayer extends EntityHuman implements ICrafting {
 
+    // Servett Start
+    public static EntityPlayer tickingPlayer;
+    public static final Object tickingPlayerLock = new Object();
+    // Servett End
+
     private static final Logger LOGGER = LogManager.getLogger();
+    public final Map<Long, Chunk.PlayerBlockModification> modifiedBlocks = new HashMap<>(); // Servett
     public String locale = null; // CraftBukkit - lowercase // Paper - default to null
     public PlayerConnection playerConnection;
     public final MinecraftServer server;
@@ -378,69 +385,77 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     @Override
     public void tick() {
-        // CraftBukkit start
-        if (this.joining) {
-            this.joining = false;
-        }
-        // CraftBukkit end
-        this.playerInteractManager.a();
-        --this.invulnerableTicks;
-        if (this.noDamageTicks > 0) {
-            --this.noDamageTicks;
-        }
+        synchronized (world.tickingPlayerLock) { // Servett Start
+            world.tickingPlayer = this; // Servett
+            tickingPlayerLock = this; // Servett
 
-        // Paper start - Configurable container update tick rate
-        if (--containerUpdateDelay <= 0) {
-            this.activeContainer.c();
-            containerUpdateDelay = world.paperConfig.containerUpdateTickRate;
-        }
-        // Paper end
-        if (!this.world.isClientSide && !this.activeContainer.canUse(this)) {
-            this.closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper
-            this.activeContainer = this.defaultContainer;
-        }
+            // CraftBukkit start
+            if (this.joining) {
+                this.joining = false;
+            }
+            // CraftBukkit end
+            this.playerInteractManager.a();
+            --this.invulnerableTicks;
+            if (this.noDamageTicks > 0) {
+                --this.noDamageTicks;
+            }
+
+            // Paper start - Configurable container update tick rate
+            if (--containerUpdateDelay <= 0) {
+                this.activeContainer.c();
+                containerUpdateDelay = world.paperConfig.containerUpdateTickRate;
+            }
+            // Paper end
+            if (!this.world.isClientSide && !this.activeContainer.canUse(this)) {
+                this.closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper
+                this.activeContainer = this.defaultContainer;
+            }
 
-        while (!this.removeQueue.isEmpty()) {
-            int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
-            int[] aint = new int[i];
-            //Iterator<Integer> iterator = this.removeQueue.iterator(); // Paper
-            int j = 0;
+            while (!this.removeQueue.isEmpty()) {
+                int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
+                int[] aint = new int[i];
+                //Iterator<Integer> iterator = this.removeQueue.iterator(); // Paper
+                int j = 0;
 
-            // Paper start
+                // Paper start
             /* while (iterator.hasNext() && j < i) {
                 aint[j++] = (Integer) iterator.next();
                 iterator.remove();
             } */
 
-            Integer integer;
-            while (j < i && (integer = this.removeQueue.poll()) != null) {
-                aint[j++] = integer.intValue();
-            }
-            // Paper end
+                Integer integer;
+                while (j < i && (integer = this.removeQueue.poll()) != null) {
+                    aint[j++] = integer.intValue();
+                }
+                // Paper end
 
-            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
-        }
+                this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
+            }
 
-        Entity entity = this.getSpecatorTarget();
+            Entity entity = this.getSpecatorTarget();
 
-        if (entity != this) {
-            if (entity.isAlive()) {
-                this.setLocation(entity.locX(), entity.locY(), entity.locZ(), entity.yaw, entity.pitch);
-                this.getWorldServer().getChunkProvider().movePlayer(this);
-                if (this.dU()) {
+            if (entity != this) {
+                if (entity.isAlive()) {
+                    this.setLocation(entity.locX(), entity.locY(), entity.locZ(), entity.yaw, entity.pitch);
+                    this.getWorldServer().getChunkProvider().movePlayer(this);
+                    if (this.dU()) {
+                        this.setSpectatorTarget(this);
+                    }
+                } else {
                     this.setSpectatorTarget(this);
                 }
-            } else {
-                this.setSpectatorTarget(this);
             }
-        }
 
-        CriterionTriggers.w.a(this);
-        if (this.co != null) {
-            CriterionTriggers.u.a(this, this.co, this.ticksLived - this.cp);
-        }
+            CriterionTriggers.w.a(this);
+            if (this.co != null) {
+                CriterionTriggers.u.a(this, this.co, this.ticksLived - this.cp);
+            }
+
+            this.advancementDataPlayer.b(this);
 
-        this.advancementDataPlayer.b(this);
+            world.tickingPlayer = null; // Servett
+            tickingPlayer = null; // Servett
+        }
     }
 
     public void playerTick() {
diff --git a/src/main/java/net/minecraft/server/IBlockAccess.java b/src/main/java/net/minecraft/server/IBlockAccess.java
index 29cdc00875aa5004132820f36e781c7bf4573162..9c9339930a163e5fec8a5c2029fa2ec8a6f890e3 100644
--- a/src/main/java/net/minecraft/server/IBlockAccess.java
+++ b/src/main/java/net/minecraft/server/IBlockAccess.java
@@ -1,8 +1,8 @@
 package net.minecraft.server;
 
+import javax.annotation.Nullable;
 import java.util.function.BiFunction;
 import java.util.function.Function;
-import javax.annotation.Nullable;
 
 public interface IBlockAccess {
 
@@ -11,6 +11,7 @@ public interface IBlockAccess {
 
     IBlockData getTypeIfLoaded(BlockPosition blockposition); // Paper - if loaded util
     IBlockData getType(BlockPosition blockposition);
+    IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer); // Servett
 
     Fluid getFluidIfLoaded(BlockPosition blockposition); // Paper - if loaded util
     Fluid getFluid(BlockPosition blockposition);
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index c6bd623921788c4bfd0e116c724d8ed1ce232265..7ec7d8399759c3dbd36e2ddcea224267d1c45078 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import co.aikar.timings.MinecraftTimings;
+import com.destroystokyo.paper.event.player.PlayerJumpEvent;
 import com.google.common.primitives.Doubles;
 import com.google.common.primitives.Floats;
 import com.mojang.brigadier.ParseResults;
@@ -9,19 +11,9 @@ import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import it.unimi.dsi.fastutil.ints.Int2ShortMap;
 import it.unimi.dsi.fastutil.ints.Int2ShortOpenHashMap;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.Optional;
-import java.util.Set;
-import javax.annotation.Nullable;
-import org.apache.commons.lang3.StringEscapeUtils;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -59,9 +51,16 @@ import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.util.NumberConversions;
-import com.destroystokyo.paper.event.player.IllegalPacketEvent; // Paper
-import com.destroystokyo.paper.event.player.PlayerJumpEvent; // Paper
-import co.aikar.timings.MinecraftTimings; // Paper
+
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+// CraftBukkit start
 // CraftBukkit end
 
 public class PlayerConnection implements PacketListenerPlayIn {
@@ -604,7 +603,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
 
             if (commandblocklistenerabstract != null) {
                 TileEntityCommand.Type tileentitycommand_type = tileentitycommand.m();
-                EnumDirection enumdirection = (EnumDirection) this.player.world.getType(blockposition).get(BlockCommand.a);
+                EnumDirection enumdirection = (EnumDirection) this.player.world.getType(blockposition, this.player).get(BlockCommand.a);
                 IBlockData iblockdata;
 
                 switch (packetplayinsetcommandblock.g()) {
@@ -705,7 +704,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
         PlayerConnectionUtils.ensureMainThread(packetplayinstruct, this, this.player.getWorldServer());
         if (this.player.isCreativeAndOp()) {
             BlockPosition blockposition = packetplayinstruct.b();
-            IBlockData iblockdata = this.player.world.getType(blockposition);
+            IBlockData iblockdata = this.player.world.getType(blockposition, this.player);
             TileEntity tileentity = this.player.world.getTileEntity(blockposition);
 
             if (tileentity instanceof TileEntityStructure) {
@@ -763,7 +762,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
         PlayerConnectionUtils.ensureMainThread(packetplayinsetjigsaw, this, this.player.getWorldServer());
         if (this.player.isCreativeAndOp()) {
             BlockPosition blockposition = packetplayinsetjigsaw.b();
-            IBlockData iblockdata = this.player.world.getType(blockposition);
+            IBlockData iblockdata = this.player.world.getType(blockposition, this.player);
             TileEntity tileentity = this.player.world.getTileEntity(blockposition);
 
             if (tileentity instanceof TileEntityJigsaw) {
@@ -1359,7 +1358,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
         MovingObjectPositionBlock movingobjectpositionblock = packetplayinuseitem.c();
         BlockPosition blockposition = movingobjectpositionblock.getBlockPosition();
         EnumDirection enumdirection = movingobjectpositionblock.getDirection();
-        IBlockData clickedBlock = worldserver.getType(blockposition); // Spigot
+        IBlockData clickedBlock = worldserver.getType(blockposition, this.player); // Spigot
 
         this.player.resetIdleTimer();
         if (blockposition.getY() >= this.minecraftServer.getMaxBuildHeight() - 1 && ((enumdirection == EnumDirection.UP && !(clickedBlock.getBlock() instanceof BlockStepAbstract && clickedBlock.get(BlockStepAbstract.a) == BlockPropertySlabType.BOTTOM)) || blockposition.getY() >= this.minecraftServer.getMaxBuildHeight())) { // Spigot
@@ -2546,7 +2545,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
         BlockPosition blockposition = packetplayinupdatesign.b();
 
         if (worldserver.isLoaded(blockposition)) {
-            IBlockData iblockdata = worldserver.getType(blockposition);
+            IBlockData iblockdata = worldserver.getType(blockposition, this.player);
             TileEntity tileentity = worldserver.getTileEntity(blockposition);
 
             if (!(tileentity instanceof TileEntitySign)) {
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index 1b60310bb01aa0c361005ccecccf3cdccd4aa72b..fd15ef2c9e2b53181dbd70a0b9097fb26c3b0eee 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -1,16 +1,18 @@
 package net.minecraft.server;
 
-import java.util.Objects;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-// CraftBukkit start
-import java.util.ArrayList;
 import org.bukkit.craftbukkit.block.CraftBlock;
-import org.bukkit.event.block.BlockBreakEvent;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
+import org.bukkit.event.block.BlockBreakEvent;
 import org.bukkit.event.player.PlayerInteractEvent;
+
+import java.util.ArrayList;
+import java.util.Objects;
+
+// CraftBukkit start
 // CraftBukkit end
 
 public class PlayerInteractManager {
@@ -84,7 +86,7 @@ public class PlayerInteractManager {
         IBlockData iblockdata;
 
         if (this.i) {
-            iblockdata = this.world.getType(this.j);
+            iblockdata = this.world.getType(this.j, this.player);
             if (iblockdata.isAir()) {
                 this.i = false;
             } else {
@@ -96,7 +98,7 @@ public class PlayerInteractManager {
                 }
             }
         } else if (this.e) {
-            iblockdata = this.world.getType(this.g);
+            iblockdata = this.world.getType(this.g, this.player);
             if (iblockdata.isAir()) {
                 this.world.a(this.player.getId(), this.g, -1);
                 this.l = -1;
@@ -134,9 +136,9 @@ public class PlayerInteractManager {
         double d3 = d0 * d0 + d1 * d1 + d2 * d2;
 
         if (d3 > 36.0D) {
-            this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition), packetplayinblockdig_enumplayerdigtype, false, "too far"));
+            this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition, this.player), packetplayinblockdig_enumplayerdigtype, false, "too far"));
         } else if (blockposition.getY() >= i) {
-            this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition), packetplayinblockdig_enumplayerdigtype, false, "too high"));
+            this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition, this.player), packetplayinblockdig_enumplayerdigtype, false, "too high"));
         } else {
             IBlockData iblockdata;
 
@@ -144,7 +146,7 @@ public class PlayerInteractManager {
                 if (!this.world.a((EntityHuman) this.player, blockposition)) {
                     // CraftBukkit start - fire PlayerInteractEvent
                     CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_BLOCK, blockposition, enumdirection, this.player.inventory.getItemInHand(), EnumHand.MAIN_HAND);
-                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition), packetplayinblockdig_enumplayerdigtype, false, "may not interact"));
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition, this.player), packetplayinblockdig_enumplayerdigtype, false, "may not interact"));
                     // Update any tile entity data for this block
                     TileEntity tileentity = world.getTileEntity(blockposition);
                     if (tileentity != null) {
@@ -177,14 +179,14 @@ public class PlayerInteractManager {
                     if (!this.world.douseFire((EntityHuman) null, blockposition, enumdirection)) {
                         this.a(blockposition, packetplayinblockdig_enumplayerdigtype, "creative destroy");
                     } else {
-                        this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition), packetplayinblockdig_enumplayerdigtype, true, "fire put out"));
+                        this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition, this.player), packetplayinblockdig_enumplayerdigtype, true, "fire put out"));
                     }
 
                     return;
                 }
 
                 if (this.player.a((World) this.world, blockposition, this.gamemode)) {
-                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition), packetplayinblockdig_enumplayerdigtype, false, "block action restricted"));
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(blockposition, this.world.getType(blockposition, this.player), packetplayinblockdig_enumplayerdigtype, false, "block action restricted"));
                     return;
                 }
 
@@ -192,11 +194,11 @@ public class PlayerInteractManager {
                 this.lastDigTick = this.currentTick; this.lastDigTime = System.nanoTime(); // Tuinity - lag compensate block breaking
                 float f = 1.0F;
 
-                iblockdata = this.world.getType(blockposition);
+                iblockdata = this.world.getType(blockposition, player);
                 // CraftBukkit start - Swings at air do *NOT* exist.
                 if (event.useInteractedBlock() == Event.Result.DENY) {
                     // If we denied a door from opening, we need to send a correcting update to the client, as it already opened the door.
-                    IBlockData data = this.world.getType(blockposition);
+                    IBlockData data = this.world.getType(blockposition, player);
                     if (data.getBlock() instanceof BlockDoor) {
                         // For some reason *BOTH* the bottom/top part have to be marked updated.
                         boolean bottom = data.get(BlockDoor.HALF) == BlockPropertyDoubleBlockHalf.LOWER;
@@ -236,7 +238,7 @@ public class PlayerInteractManager {
                     this.a(blockposition, packetplayinblockdig_enumplayerdigtype, "insta mine");
                 } else {
                     if (this.e) {
-                        this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(this.g, this.world.getType(this.g), PacketPlayInBlockDig.EnumPlayerDigType.START_DESTROY_BLOCK, false, "abort destroying since another started (client insta mine, server disagreed)"));
+                        this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(this.g, this.world.getType(this.g, this.player), PacketPlayInBlockDig.EnumPlayerDigType.START_DESTROY_BLOCK, false, "abort destroying since another started (client insta mine, server disagreed)"));
                     }
 
                     this.e = true;
@@ -251,7 +253,7 @@ public class PlayerInteractManager {
                 if (blockposition.equals(this.g)) {
                     int k = this.getTimeDiggingLagCompensate(); // Tuinity - lag compensate block breaking
 
-                    iblockdata = this.world.getType(blockposition);
+                    iblockdata = this.world.getType(blockposition, player);
                     if (!iblockdata.isAir()) {
                         float f1 = iblockdata.getDamage(this.player, this.player.world, blockposition) * (float) (k + 1);
 
@@ -277,7 +279,7 @@ public class PlayerInteractManager {
                 if (!Objects.equals(this.g, blockposition)) {
                     PlayerInteractManager.LOGGER.debug("Mismatch in destroy block pos: " + this.g + " " + blockposition); // CraftBukkit - SPIGOT-5457 sent by client when interact event cancelled
                     this.world.a(this.player.getId(), this.g, -1);
-                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(this.g, this.world.getType(this.g), packetplayinblockdig_enumplayerdigtype, true, "aborted mismatched destroying"));
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockBreak(this.g, this.world.getType(this.g, this.player), packetplayinblockdig_enumplayerdigtype, true, "aborted mismatched destroying"));
                 }
 
                 this.world.a(this.player.getId(), blockposition, -1);
@@ -299,7 +301,7 @@ public class PlayerInteractManager {
     }
 
     public boolean breakBlock(BlockPosition blockposition) {
-        IBlockData iblockdata = this.world.getType(blockposition);
+        IBlockData iblockdata = this.world.getType(blockposition, player);
         // CraftBukkit start - fire BlockBreakEvent
         org.bukkit.block.Block bblock = CraftBlock.at(world, blockposition);
         BlockBreakEvent event = null;
@@ -322,7 +324,7 @@ public class PlayerInteractManager {
             event.setCancelled(isSwordNoBreak);
 
             // Calculate default block experience
-            IBlockData nmsData = this.world.getType(blockposition);
+            IBlockData nmsData = this.world.getType(blockposition, player);
             Block nmsBlock = nmsData.getBlock();
 
             ItemStack itemstack = this.player.getEquipment(EnumItemSlot.MAINHAND);
@@ -358,7 +360,7 @@ public class PlayerInteractManager {
         if (false && !this.player.getItemInMainHand().getItem().a(iblockdata, (World) this.world, blockposition, (EntityHuman) this.player)) { // CraftBukkit - false
             return false;
         } else {
-            iblockdata = this.world.getType(blockposition); // CraftBukkit - update state from plugins
+            iblockdata = this.world.getType(blockposition, player); // CraftBukkit - update state from plugins
             if (iblockdata.isAir()) return false; // CraftBukkit - A plugin set block to air without cancelling
             TileEntity tileentity = this.world.getTileEntity(blockposition);
             Block block = iblockdata.getBlock();
@@ -453,7 +455,7 @@ public class PlayerInteractManager {
     public boolean firedInteract = false;
     public EnumInteractionResult a(EntityHuman entityhuman, World world, ItemStack itemstack, EnumHand enumhand, MovingObjectPositionBlock movingobjectpositionblock) {
         BlockPosition blockposition = movingobjectpositionblock.getBlockPosition();
-        IBlockData iblockdata = world.getType(blockposition);
+        IBlockData iblockdata = world.getType(blockposition, player);
         EnumInteractionResult enuminteractionresult = EnumInteractionResult.PASS;
         boolean cancelledBlock = false;
 
diff --git a/src/main/java/net/minecraft/server/ProtoChunk.java b/src/main/java/net/minecraft/server/ProtoChunk.java
index 5a883aac14052f6637acbf4cf96236936fee98c3..d75458abe3affc0986969761e15e520e77b03c56 100644
--- a/src/main/java/net/minecraft/server/ProtoChunk.java
+++ b/src/main/java/net/minecraft/server/ProtoChunk.java
@@ -6,6 +6,10 @@ import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.annotation.Nullable;
 import java.util.BitSet;
 import java.util.Collection;
 import java.util.Collections;
@@ -13,12 +17,9 @@ import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Set;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 public class ProtoChunk implements IChunkAccess {
 
@@ -106,6 +107,21 @@ public class ProtoChunk implements IChunkAccess {
 
     @Override
     public IBlockData getType(BlockPosition blockposition) {
+        // Servett Start
+        if (world instanceof World) {
+            final World world = (World) this.world;
+            synchronized (world.tickingPlayerLock) {
+                if (world.tickingPlayer != null) {
+                    final Chunk.PlayerBlockModification playerBlockModification =
+                        world.tickingPlayer.modifiedBlocks.get(blockposition.asLong());
+                    if (playerBlockModification != null) {
+                        return playerBlockModification.getModifiedBlock();
+                    }
+                }
+            }
+        }
+        // Servett End
+
         int i = blockposition.getY();
 
         if (World.b(i)) {
@@ -117,6 +133,27 @@ public class ProtoChunk implements IChunkAccess {
         }
     }
 
+    // Servett Start
+    @Override
+    public IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        final Chunk.PlayerBlockModification playerBlockModification =
+            tickingPlayer.modifiedBlocks.get(position.asLong());
+        if (playerBlockModification != null) {
+            return playerBlockModification.getModifiedBlock();
+        }
+
+        int i = position.getY();
+
+        if (World.b(i)) {
+            return Blocks.VOID_AIR.getBlockData();
+        } else {
+            ChunkSection chunksection = this.getSections()[i >> 4];
+
+            return ChunkSection.a(chunksection) ? Blocks.AIR.getBlockData() : chunksection.getType(position.getX() & 15, i & 15, position.getZ() & 15);
+        }
+    }
+    // Servett End
+
     @Override
     public Fluid getFluid(BlockPosition blockposition) {
         int i = blockposition.getY();
@@ -215,7 +252,7 @@ public class ProtoChunk implements IChunkAccess {
 
     public ChunkSection a(int i) {
         if (this.j[i] == Chunk.a) {
-            this.j[i] = new ChunkSection(i << 4, this, this.world, true); // Paper - Anti-Xray
+            this.j[i] = new ChunkSection((World) world, i << 4, this, this.world, true); // Paper - Anti-Xray
         }
 
         return this.j[i];
diff --git a/src/main/java/net/minecraft/server/RegionLimitedWorldAccess.java b/src/main/java/net/minecraft/server/RegionLimitedWorldAccess.java
index 9d0e8c2d43ba56d53bc30c0a3e2d7d170d8be474..6a7258e173557658cdf5e520c3254c60746330db 100644
--- a/src/main/java/net/minecraft/server/RegionLimitedWorldAccess.java
+++ b/src/main/java/net/minecraft/server/RegionLimitedWorldAccess.java
@@ -1,12 +1,13 @@
 package net.minecraft.server;
 
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.annotation.Nullable;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 public class RegionLimitedWorldAccess implements GeneratorAccess {
 
@@ -130,9 +131,32 @@ public class RegionLimitedWorldAccess implements GeneratorAccess {
 
     @Override
     public IBlockData getType(BlockPosition blockposition) {
+        // Servett Start
+        synchronized (f.tickingPlayerLock) {
+            if (f.tickingPlayer != null) {
+                Chunk.PlayerBlockModification playerBlockModification =
+                    f.tickingPlayer.modifiedBlocks.get(blockposition.asLong());
+                if (playerBlockModification != null) {
+                    return playerBlockModification.getModifiedBlock();
+                }
+            }
+        }
+        // Servett End
         return this.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4).getType(blockposition);
     }
 
+    // Servett Start
+    @Override public
+    IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        Chunk.PlayerBlockModification playerBlockModification
+            = tickingPlayer.modifiedBlocks.get(position.asLong());
+        if (playerBlockModification != null) {
+            return playerBlockModification.getModifiedBlock();
+        }
+        return this.getChunkAt(position.getX() >> 4, position.getZ() >> 4).getType(position);
+    }
+    // Servett End
+
     @Override
     public Fluid getFluid(BlockPosition blockposition) {
         return this.x(blockposition).getFluid(blockposition);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index d066a4144f3eb41c6c73677c2a7eab22f65f9750..458d610b6c8134a595a0ed1d2e673a03c221c46b 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1,37 +1,34 @@
 package net.minecraft.server;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
-import com.destroystokyo.paper.antixray.ChunkPacketBlockController; // Paper - Anti-Xray
-import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray; // Paper - Anti-Xray
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.function.BiFunction;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.util.Supplier;
-
-// CraftBukkit start
-import java.util.HashMap;
-import java.util.Map;
 import org.bukkit.Bukkit;
-import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+// CraftBukkit start
 // CraftBukkit end
 
 public abstract class World implements GeneratorAccess, AutoCloseable {
@@ -60,6 +57,11 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     private final WorldBorder worldBorder;
     private final BiomeManager biomeManager;
 
+    // Servett Start
+    public EntityPlayer tickingPlayer;
+    public final java.lang.Object tickingPlayerLock = new Object();
+    // Servett End
+
     // CraftBukkit start Added the following
     private final CraftWorld world;
     public boolean pvpMode;
@@ -636,6 +638,18 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
 
     @Override
     public IBlockData getType(BlockPosition blockposition) {
+        // Servett Start
+        synchronized (tickingPlayerLock) {
+            if (tickingPlayer != null) {
+                Chunk.PlayerBlockModification playerBlockModification =
+                    tickingPlayer.modifiedBlocks.get(blockposition.asLong());
+                if (playerBlockModification != null) {
+                    return playerBlockModification.getModifiedBlock();
+                }
+            }
+        }
+        // Servett End
+
         // CraftBukkit start - tree generation
         if (captureTreeGeneration) {
             CraftBlockState previous = capturedBlockStates.get(blockposition); // Paper
@@ -653,6 +667,32 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         }
     }
 
+    // Servett Start
+    @Override
+    public IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        Chunk.PlayerBlockModification playerBlockModification =
+            tickingPlayer.modifiedBlocks.get(position.asLong());
+        if (playerBlockModification != null) {
+            return playerBlockModification.getModifiedBlock();
+        }
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            CraftBlockState previous = capturedBlockStates.get(position); // Paper
+            if (previous != null) {
+                return previous.getHandle();
+            }
+        }
+        // CraftBukkit end
+        if (isOutsideWorld(position)) {
+            return Blocks.VOID_AIR.getBlockData();
+        } else {
+            Chunk chunk = this.getChunkAt(position.getX() >> 4, position.getZ() >> 4);
+
+            return chunk.getType(position);
+        }
+    }
+    // Servett End
+
     @Override
     public Fluid getFluid(BlockPosition blockposition) {
         if (isOutsideWorld(blockposition)) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 9cff8b88baea65a26aec82d51014a54a70ea31aa..ddd08b62723e72e5b48550911b9e305d2f5f28fc 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -1,10 +1,6 @@
 package org.bukkit.craftbukkit;
 
 import com.google.common.base.Preconditions;
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Collection;
-import net.minecraft.server.BiomeBase;
 import net.minecraft.server.BiomeStorage;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.Blocks;
@@ -34,12 +30,16 @@ import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.entity.Entity;
 import org.bukkit.plugin.Plugin;
 
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+import java.util.Collection;
+
 public class CraftChunk implements Chunk {
     private WeakReference<net.minecraft.server.Chunk> weakChunk;
     private final WorldServer worldServer;
     private final int x;
     private final int z;
-    private static final DataPaletteBlock<IBlockData> emptyBlockIDs = new ChunkSection(0).getBlocks();
+    private static final DataPaletteBlock<IBlockData> emptyBlockIDs = new ChunkSection(null, 0).getBlocks();
     private static final byte[] emptyLight = new byte[2048];
 
     public CraftChunk(net.minecraft.server.Chunk chunk) {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index 78e84c3d6d5f0e1dc0490f9f6c106b84e4853f8d..42997d73d2d691fbf8290f567e90de2a7b9abb80 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -1,16 +1,13 @@
 package org.bukkit.craftbukkit.block;
 
 import com.google.common.base.Preconditions;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.stream.Collectors;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.BiomeBase;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.BlockRedstoneWire;
 import net.minecraft.server.BlockTileEntity;
 import net.minecraft.server.Blocks;
+import net.minecraft.server.EntityPlayer;
 import net.minecraft.server.EnumDirection;
 import net.minecraft.server.EnumSkyBlock;
 import net.minecraft.server.GeneratorAccess;
@@ -35,12 +32,15 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
 import org.bukkit.block.PistonMoveReaction;
 import org.bukkit.block.data.BlockData;
+import org.bukkit.craftbukkit.CraftChunk;
 import org.bukkit.craftbukkit.CraftFluidCollisionMode;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.craftbukkit.util.CraftRayTraceResult;
+import org.bukkit.entity.Player;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
@@ -49,6 +49,11 @@ import org.bukkit.util.BoundingBox;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
 
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
 public class CraftBlock implements Block {
     private final net.minecraft.server.GeneratorAccess world;
     private final BlockPosition position;
@@ -712,4 +717,47 @@ public class CraftBlock implements Block {
         return new com.destroystokyo.paper.block.CraftBlockSoundGroup(getNMSBlock().getBlockData().getStepSound());
     }
     // Paper end
+
+    // Servett Start
+    @Override
+    public void setPlayerModifiedBlock(Player player, BlockData type) {
+        // Track internally
+        ((CraftChunk) getChunk()).getHandle().addPlayerModifiedBlock(
+            this.getX(),
+            this.getY(), this.getZ(),
+            ((CraftPlayer) player).getHandle(),
+            ((CraftBlockData) type).getState());
+        // Send block change
+        player.sendBlockChange(this.getLocation(), type);
+    }
+
+    @Override
+    public void removePlayerModifiedBlock(Player player) {
+        // Remove internally
+        ((CraftChunk) getChunk()).getHandle().removePlayerModifiedBlock(
+            this.getX(),
+            this.getY(),
+            this.getZ(),
+            ((CraftPlayer) player).getHandle());
+        // Send block change
+        player.sendBlockChange(this.getLocation(), getBlockData());
+    }
+
+    @Override
+    public BlockData getPlayerKnownBlock(Player player) {
+        final WorldServer worldServer = getCraftWorld().getHandle();
+        BlockData material;
+        synchronized (worldServer.tickingPlayerLock) {
+            final EntityPlayer oldPlayer = worldServer.tickingPlayer;
+            try {
+                worldServer.tickingPlayer = ((CraftPlayer) player).getHandle();
+                material = getBlockData();
+            } finally {
+                worldServer.tickingPlayer = oldPlayer;
+            }
+        }
+        return material;
+    }
+    // Servett End
+
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CraftChunkData.java b/src/main/java/org/bukkit/craftbukkit/generator/CraftChunkData.java
index 969d548de2c6ba4f9df959f73d7324874101a6f6..7babb67e41a0a385c675327fb6e8b7f395bb890b 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CraftChunkData.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CraftChunkData.java
@@ -1,7 +1,5 @@
 package org.bukkit.craftbukkit.generator;
 
-import java.util.HashSet;
-import java.util.Set;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.Blocks;
 import net.minecraft.server.ChunkSection;
@@ -14,6 +12,9 @@ import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.material.MaterialData;
 
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  * Data to be used for the block types and data in a newly generated chunk.
  */
@@ -159,7 +160,8 @@ public final class CraftChunkData implements ChunkGenerator.ChunkData {
     private ChunkSection getChunkSection(int y, boolean create) {
         ChunkSection section = sections[y >> 4];
         if (create && section == null) {
-            sections[y >> 4] = section = new ChunkSection(y >> 4 << 4, null, world instanceof org.bukkit.craftbukkit.CraftWorld ? ((org.bukkit.craftbukkit.CraftWorld) world).getHandle() : null, true); // Paper - Anti-Xray
+            sections[y >> 4] = section = new ChunkSection(world instanceof org.bukkit.craftbukkit.CraftWorld ? ((org.bukkit.craftbukkit.CraftWorld) world).getHandle() : null,
+                y >> 4 << 4, null, world instanceof org.bukkit.craftbukkit.CraftWorld ? ((org.bukkit.craftbukkit.CraftWorld) world).getHandle() : null, true); // Paper - Anti-Xray
         }
         return section;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java b/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java
index d0b813008ca21fe6aa9b514ed4325596113fd459..b1fc5116af64e72d9ebd725df7c01fda1bcea5f7 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java
@@ -1,8 +1,5 @@
 package org.bukkit.craftbukkit.util;
 
-import java.util.List;
-import java.util.Random;
-import java.util.function.Predicate;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.BiomeBase;
 import net.minecraft.server.BiomeManager;
@@ -12,6 +9,7 @@ import net.minecraft.server.ChunkStatus;
 import net.minecraft.server.DifficultyDamageScaler;
 import net.minecraft.server.Entity;
 import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
 import net.minecraft.server.Fluid;
 import net.minecraft.server.FluidType;
 import net.minecraft.server.GeneratorAccess;
@@ -30,6 +28,10 @@ import net.minecraft.server.WorldBorder;
 import net.minecraft.server.WorldData;
 import net.minecraft.server.WorldProvider;
 
+import java.util.List;
+import java.util.Random;
+import java.util.function.Predicate;
+
 public class DummyGeneratorAccess implements GeneratorAccess {
 
     public static final GeneratorAccess INSTANCE = new DummyGeneratorAccess();
@@ -214,4 +216,11 @@ public class DummyGeneratorAccess implements GeneratorAccess {
         throw new UnsupportedOperationException("Not supported yet.");
     }
     // Paper end
+
+    // Servett Start
+    @Override public IBlockData getType(BlockPosition position, EntityPlayer tickingPlayer) {
+        return getType(position);
+    }
+    // Servett End
+
 }
